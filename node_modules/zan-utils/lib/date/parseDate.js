(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['module', 'exports', 'fecha'], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require('fecha'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.fecha);
    global.parseDate = mod.exports;
  }
})(this, function (module, exports, _fecha) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  /**
   * 解析日期，字符串转化为日期
   * @memberof module:date
   * @param {String} date 需要解析的 date，默认应该传入字符串，但对下面两个情况也做了兼容:
   * - 如果传入Date的实例则直接返回这个实例;
   * - 如果传入时间戳数字，则返回 new Date(date) 函数调用后的值;
   * @param {String} mask 解析的格式
   * @see {@link https://github.com/taylorhakes/fecha#parsing|parse文档}
   * @returns {Date} 转化后的日期
   * @runkit true
   * @example
   * const parseDate = require('zan-utils/date/parseDate');
   * parseDate('February 3rd, 2014', 'MMMM Do, YYYY'); // new Date(2014, 1, 3)
   * parseDate('10-12-10 14:11:12', 'YY-MM-DD HH:mm:ss'); // new Date(2010, 11, 10, 14, 11, 12)
   * parseDate('5/3/98', 'shortDate'); // new Date(1998, 4, 3)
   * parseDate('November 4, 2005', 'longDate'); // new Date(2005, 10, 4)
   */
  function parseDate(date) {
    var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

    mask = mask || 'default';
    if (date instanceof Date) return date;
    if (typeof date === 'number') return new Date(date);

    var ret = (0, _fecha.parse)(date, mask);
    if (!ret) {
      // eslint-disable-line
      return null;
    }
    return ret;
  }
  exports['default'] = parseDate;
  module.exports = exports['default'];
});