'use strict';

exports.__esModule = true;

var _components;

var _cell = require('../cell');

var _cell2 = _interopRequireDefault(_cell);

var _icon = require('../icon');

var _icon2 = _interopRequireDefault(_icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VALID_TYPES = ['text', 'number', 'email', 'url', 'tel', 'date', 'time', 'datetime', 'password', 'textarea'];

exports.default = {
  render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('van-cell', { staticClass: "van-field", class: {
        'van-field--hastextarea': _vm.type === 'textarea',
        'van-field--nolabel': !_vm.label,
        'van-field--disabled': _vm.disabled,
        'van-field--error': _vm.error,
        'van-field--border': _vm.border,
        'van-hairline--surround': _vm.border,
        'van-field--autosize': _vm.autosize,
        'van-field--has-icon': _vm.showIcon
      }, attrs: { "title": _vm.label, "required": _vm.required } }, [_vm.type === 'textarea' ? _c('textarea', { directives: [{ name: "model", rawName: "v-model", value: _vm.currentValue, expression: "currentValue" }], ref: "textareaElement", staticClass: "van-field__control", attrs: { "placeholder": _vm.placeholder, "maxlength": _vm.maxlength, "disabled": _vm.disabled, "readonly": _vm.readonly, "rows": _vm.rows, "cols": _vm.cols }, domProps: { "value": _vm.currentValue }, on: { "focus": _vm.handleInputFocus, "blur": _vm.handleInputBlur, "input": function input($event) {
          if ($event.target.composing) {
            return;
          }_vm.currentValue = $event.target.value;
        } } }) : _c('input', { staticClass: "van-field__control", attrs: { "type": _vm.type, "placeholder": _vm.placeholder, "maxlength": _vm.maxlength, "disabled": _vm.disabled, "readonly": _vm.readonly }, domProps: { "value": _vm.currentValue }, on: { "input": _vm.handleInput, "focus": _vm.handleInputFocus, "blur": _vm.handleInputBlur } }), _vm.showIcon ? _c('div', { staticClass: "van-field__icon", on: { "click": _vm.onIconClick } }, [_vm._t("icon", [_c('van-icon', { attrs: { "name": _vm.icon } })])], 2) : _vm._e()]);
  },

  name: 'van-field',

  components: (_components = {}, _components[_cell2.default.name] = _cell2.default, _components[_icon2.default.name] = _icon2.default, _components),

  props: {
    type: {
      type: String,
      default: 'text',
      validator: function validator(value) {
        return VALID_TYPES.indexOf(value) > -1;
      }
    },
    value: {},
    icon: String,
    label: String,
    placeholder: String,
    error: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    required: Boolean,
    maxlength: [String, Number],
    border: Boolean,
    rows: [String, Number],
    cols: [String, Number],
    autosize: {
      type: Boolean,
      default: false
    },
    onIconClick: {
      type: Function,
      default: function _default() {}
    }
  },

  data: function data() {
    return {
      currentValue: this.value
    };
  },
  mounted: function mounted() {
    if (this.autosize && this.type === 'textarea') {
      var el = this.$refs.textareaElement;
      el.style.height = el.scrollHeight + 'px';
      el.style.overflowY = 'hidden';
    }
  },


  watch: {
    value: function value(val) {
      this.currentValue = val;
    },
    currentValue: function currentValue(val) {
      if (this.autosize && this.type === 'textarea') {
        this.$nextTick(this.sizeAdjust);
      }
      this.$emit('input', val);
    }
  },

  computed: {
    showIcon: function showIcon() {
      // 有icon的slot，就认为一直展示
      if (this.$slots.icon) {
        return true;
      }

      return this.icon && this.currentValue;
    }
  },

  methods: {
    handleInput: function handleInput(event) {
      this.currentValue = event.target.value;
    },
    sizeAdjust: function sizeAdjust() {
      var el = this.$refs.textareaElement;
      el.style.height = 'auto';
      el.style.height = el.scrollHeight + 'px';
    },
    handleInputFocus: function handleInputFocus() {
      this.$emit('focus');
    },
    handleInputBlur: function handleInputBlur() {
      this.$emit('blur');
    }
  }
};